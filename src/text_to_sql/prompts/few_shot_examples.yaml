- name: "Combined Ranking Example"
  question: "Give me top 25 batsmen with a combination of best strike rate and average in ipl 2025 having equal weightage for both strikerate and average"
  sql: |
    WITH BatterStats AS (
      SELECT
        d.batter_identifier,
        SUM(d.runs_batter) AS total_runs,
        SUM(CASE WHEN d.extras_wides = 0 THEN 1 ELSE 0 END) AS total_balls_faced,
        COUNT(w.wicket_id) AS total_outs
      FROM Deliveries AS d
      JOIN Innings AS i ON d.inning_id = i.inning_id AND NOT i.is_super_over -- Do not consider super over stats, default case
      JOIN Matches AS m ON i.match_id = m.match_id
      LEFT JOIN Wickets AS w ON d.delivery_id = w.delivery_id AND d.batter_identifier = w.player_out_identifier
      WHERE m.season_year = 2025
      GROUP BY d.batter_identifier
      HAVING SUM(CASE WHEN d.extras_wides = 0 THEN 1 ELSE 0 END) >= 50
    ),
    CalculatedAverages AS (
      SELECT
        p.first_last_name as name, -- Use this field always to display the player names for the final output
        s.total_runs,
        (s.total_runs::FLOAT / NULLIF(s.total_balls_faced, 0)) * 100 AS strike_rate,
        (s.total_runs::FLOAT / NULLIF(s.total_outs, 0)) AS batting_average
      FROM BatterStats AS s
      JOIN Players AS p ON s.batter_identifier = p.identifier
    ),
    RankedStats AS (
      SELECT
        name,
        strike_rate,
        batting_average,
        RANK() OVER (ORDER BY strike_rate DESC) AS rank_sr,
        RANK() OVER (ORDER BY batting_average DESC) AS rank_avg
      FROM CalculatedAverages
      WHERE strike_rate IS NOT NULL AND batting_average IS NOT NULL
    )
    SELECT
      name,
      ROUND(strike_rate::numeric, 2) AS strike_rate,
      ROUND(batting_average::numeric, 2) AS batting_average,
      (rank_sr + rank_avg) AS combined_rank_score
    FROM RankedStats
    ORDER BY
      combined_rank_score ASC
    LIMIT 25; -- user defined limit

- name: "Boundary Counting Example"
  question: "Which batter hit the most sixes in the 2024 season of IPL?"
  sql: |
    SELECT
      p.first_last_name AS batter_name, -- Use 'first_last_name' for player identification
      COUNT(*) AS sixes_count,
      COUNT(DISTINCT i.inning_id) AS innings_played, -- Context: Always include the denominator (innings/matches) for volume stats
      ROUND((COUNT(*)::NUMERIC / NULLIF(COUNT(DISTINCT i.inning_id), 0)), 2) AS sixes_per_inning -- Calculation: Use NULLIF to prevent divide-by-zero errors and ::NUMERIC for decimal precision
    FROM Deliveries AS d
    JOIN Players AS p
      ON d.batter_identifier = p.identifier
    JOIN Innings AS i
      ON d.inning_id = i.inning_id AND NOT i.is_super_over -- Do not consider super over stats, default case
    JOIN Matches AS m
      ON i.match_id = m.match_id
    WHERE
      d.runs_batter = 6 AND m.season_year = 2024
    GROUP BY
      p.first_last_name
    ORDER BY
      sixes_count DESC
    LIMIT 10; -- default limit

- name: "Partnership Run Rate Example"
  question: "Among batting pairs with at least 300 runs, which one had the best run rate in IPL 2024?"
  sql: |
    WITH PartnershipStats AS (
      SELECT
        LEAST(d.batter_identifier, d.non_striker_identifier) AS player1_id,
        GREATEST(d.batter_identifier, d.non_striker_identifier) AS player2_id,
        SUM(d.runs_batter) AS partnership_runs,
        -- Calculate Player 1 Runs (The player with the lower ID)
        SUM(CASE WHEN d.batter_identifier = LEAST(d.batter_identifier, d.non_striker_identifier) THEN d.runs_batter ELSE 0 END) AS p1_runs,
        -- Calculate Player 2 Runs (The player with the higher ID)
        SUM(CASE WHEN d.batter_identifier = GREATEST(d.batter_identifier, d.non_striker_identifier) THEN d.runs_batter ELSE 0 END) AS p2_runs,
        COUNT(CASE WHEN d.extras_wides = 0 AND d.extras_noballs = 0 THEN 1 END) AS legitimate_balls, -- This is the corrected logic for legitimate balls (excluding wides AND no-balls).
        SUM(CASE WHEN d.runs_batter IN (4, 6) THEN 1 ELSE 0 END) AS boundary_count, -- Count 4s and 6s for context
        COUNT(w.wicket_id) AS partnership_outs, -- Count broken partnerships for average calculation
        COUNT(DISTINCT i.inning_id) AS innings_played -- Need this to calculate per-inning averages
      FROM Deliveries d
      JOIN Innings i ON d.inning_id = i.inning_id AND NOT i.is_super_over -- Do not consider super over stats, default case
      JOIN Matches m ON i.match_id = m.match_id
      LEFT JOIN Wickets w ON d.delivery_id = w.delivery_id
      WHERE m.season_year = 2024
      GROUP BY
        LEAST(d.batter_identifier, d.non_striker_identifier),
        GREATEST(d.batter_identifier, d.non_striker_identifier)
      HAVING
        SUM(d.runs_batter) >= 300
    )
    SELECT
      p1.first_last_name AS player1, -- Use this field always to display the player names for the final output
      p2.first_last_name AS player2, -- Use this field always to display the player names for the final output
      ps.partnership_runs,
      ps.innings_played, -- Enrichment: Added innings count
      ROUND((ps.partnership_runs * 6.0 / NULLIF(ps.legitimate_balls, 0)), 2) AS run_rate,
      -- Enrichment: Create a visual text representation of the contribution
      (ps.p1_runs || ' (' || ROUND((ps.p1_runs::NUMERIC / ps.partnership_runs)*100, 0) || '%)' || 
       ' vs ' || 
       ps.p2_runs || ' (' || ROUND((ps.p2_runs::NUMERIC / ps.partnership_runs)*100, 0) || '%)') AS run_contribution_split,
      ROUND(ps.boundary_count::NUMERIC / NULLIF(ps.innings_played, 0), 2) as avg_boundaries_per_inning, -- Enrichment: Calculated average boundaries/inning
      ROUND((ps.partnership_runs::NUMERIC / NULLIF(ps.partnership_outs, 0)), 2) AS partnership_average -- Enrichment: Added average to provide deeper context
    FROM PartnershipStats ps
    JOIN Players p1 ON ps.player1_id = p1.identifier
    JOIN Players p2 ON ps.player2_id = p2.identifier
    ORDER BY run_rate DESC
    LIMIT 10; -- default limit

- name: "Hat trick checking example"
  question: "who has taken most hat tricks in ipl?"
  sql: |
    WITH Deliveries AS (
    	-- Add running_ball_number for each bowler in an inning
    	SELECT 
    		ROW_NUMBER() OVER (PARTITION BY inning_id, bowler_identifier ORDER BY delivery_id ASC) AS bowler_ball_num,
    		*
    	FROM deliveries
    ),
    BowlerWickets AS (
    	-- identify every credited wicket and its bowler
    	SELECT
    	d.inning_id,
    	d.delivery_id,
    	w.bowler_credited_identifier AS bowler_id,
    	bowler_ball_num AS wicket
    	FROM Deliveries d
    	JOIN Wickets w ON d.delivery_id = w.delivery_id
    	WHERE w.bowler_credited_identifier IS NOT NULL
    ),
    HatrickCandidates AS (
    	-- Find out the ball numbers for the previous wicket and previous-to-previous wicket
    	SELECT 
    		*,
    		LAG(wicket, 1) OVER (PARTITION BY inning_id, bowler_id ORDER BY delivery_id ASC) AS wicket_prev,
    		LAG(wicket, 2) OVER (PARTITION BY inning_id, bowler_id ORDER BY delivery_id ASC) AS wicket_prev_prev
    	FROM BowlerWickets
    )
    SELECT
    	-- If previous and previous-to-previous wicket occured in consecutive ball_numbers then consider it as a hat trick
    	p.first_last_name AS bowler_name, # Use this field always to display the player names for the final output
    	COUNT(ht.bowler_id) AS hat_tricks_count
    FROM HatrickCandidates ht
    JOIN Players p ON ht.bowler_id = p.identifier
    WHERE 
    	wicket = wicket_prev+1 AND wicket_prev = wicket_prev_prev+1
    GROUP BY
      	p.name
    ORDER BY
      	hat_tricks_count DESC
    LIMIT 10;

- name: "Runs conceded by a bowler"
  question: "How many runs Josh Hazlewood conceded in IPL 2025?"
  sql: |
    WITH TargetBowler AS MATERIALIZED (
      -- Performance Optimization: Resolve the bowler ID exactly once in a CTE using MATERIALIZED to prevent inline loop
      SELECT get_player_id_by_name('Josh Hazlewood') AS bowler_id
    ),
    BowlerStats AS (
    SELECT
        p.first_last_name as player,
        SUM(d.runs_batter) + SUM(d.extras_wides) + SUM(d.extras_noballs) AS total_runs_conceded, -- Standard definition of bowler runs. Only wides, noballs and runs scored by the batsman are tallied towards the bowler figures
        COUNT(CASE WHEN d.extras_wides = 0 AND d.extras_noballs = 0 THEN 1 END) AS legal_balls, -- Count legal deliveries to calculate overs
        COUNT(w.wicket_id) AS total_wickets, -- Enrichment: Wickets taken
        COUNT(DISTINCT i.match_id) AS matches_played -- Enrichment: Games played
    FROM Deliveries AS d
    JOIN TargetBowler tp ON d.bowler_identifier = tp.bowler_id -- Optimized Join: Matches against the static ID from the CTE
    JOIN Innings AS i ON d.inning_id = i.inning_id AND NOT i.is_super_over
    JOIN Matches AS m ON i.match_id = m.match_id
    LEFT JOIN Wickets AS w ON d.delivery_id = w.delivery_id
    JOIN Players p ON d.bowler_identifier = p.identifier
    WHERE m.season_year = 2025
    GROUP BY 1
    )
    SELECT
        bs.player,
        bs.matches_played,
        bs.total_runs_conceded,
        bs.total_wickets,
        (bs.legal_balls / 6) || '.' || (bs.legal_balls % 6) AS overs_bowled, -- Enrichment: formatting balls into Overs (e.g. 4.2 overs)
        ROUND((bs.total_runs_conceded * 6.0 / NULLIF(bs.legal_balls, 0)), 2) AS economy_rate -- Enrichment: Economy Rate calculation
    FROM BowlerStats bs;

- name: "Centuries example"
  question: "How many centuries Chris Gayle has scored in IPL?"
  sql: |
    WITH TargetPlayer AS MATERIALIZED (
      -- Performance Optimization: Resolve the player ID exactly once in a CTE using MATERIALIZED to prevent inline loop
      SELECT get_player_id_by_name('Chris Gayle') AS player_id
    ),
    BattingStats AS (
      SELECT 
        p.first_last_name AS player,
        d.inning_id,
        SUM(d.runs_batter) AS runs
      FROM Deliveries d
      JOIN TargetPlayer tp ON d.batter_identifier = tp.player_id -- Optimized Join: Matches against the static ID from the CTE
      JOIN Innings i ON d.inning_id = i.inning_id AND NOT i.is_super_over -- Exclude Super Overs
      JOIN Players p ON d.batter_identifier = p.identifier
      GROUP BY 1, 2
    )
    SELECT 
      bs.player,
      COUNT(CASE WHEN bs.runs >= 100 THEN 1 END) AS total_centuries,
      COUNT(bs.inning_id) AS innings_played, -- Enrichment: Context for consistency
      MAX(bs.runs) AS highest_score -- Enrichment: Best performance context
    FROM BattingStats bs
    GROUP BY 1;
    
- name: "Usage of time-frame based LIMIT"
  question: "What is the average first innings score in ipl season wise?"
  sql: |
    SELECT
      m.season_year,
      ROUND(AVG(total_runs)::numeric, 2) AS average_first_innings_score
    FROM Matches AS m
    JOIN Innings AS i
      ON m.match_id = i.match_id
    JOIN (
      SELECT
        inning_id,
        SUM(runs_total) AS total_runs
      FROM Deliveries
      GROUP BY
        inning_id
    ) AS d
      ON i.inning_id = d.inning_id
    WHERE
      i.inning_number = 1 AND NOT i.is_super_over
    GROUP BY
      m.season_year
    ORDER BY
      m.season_year DESC
    LIMIT 100; -- max limit, because the user is asking for a particular subset of data that is "every season")

- name: "Head-to-Head (Batter vs Bowler) Example"
  question: "Who has the highest strike rate against Jasprit Bumrah? (min 30 balls faced)"
  sql: |
    WITH TargetBowler AS MATERIALIZED (
      -- Performance Optimization: Resolve the bowler ID exactly once in a CTE using MATERIALIZED to prevent inline loop
      SELECT get_player_id_by_name('Jasprit Bumrah') AS bowler_id
    )
    SELECT
      p_bat.first_last_name AS batter_name,
      SUM(d.runs_batter) AS runs_scored,
      COUNT(*) AS balls_faced, -- Enrichment: Context for the strike rate
      COUNT(w.wicket_id) AS times_dismissed, -- Enrichment: Context showing how often the bowler wins
      ROUND((SUM(d.runs_batter) * 100.0 / NULLIF(COUNT(*), 0)), 2) AS strike_rate,
      ROUND((SUM(d.runs_batter)::NUMERIC / NULLIF(COUNT(w.wicket_id), 0)), 2) AS batting_average, -- Enrichment: Average specifically against this bowler
      -- Enrichment: Boundary Counts (Dominance)
      SUM(CASE WHEN d.runs_batter = 4 THEN 1 ELSE 0 END) AS fours,
      SUM(CASE WHEN d.runs_batter = 6 THEN 1 ELSE 0 END) AS sixes,
      -- Enrichment: Dot Ball Percentage (Pressure) - Percentage of balls where 0 runs were scored
      ROUND((SUM(CASE WHEN d.runs_batter = 0 THEN 1 ELSE 0 END) * 100.0 / NULLIF(COUNT(*), 0)), 2) AS dot_ball_pct,
      MODE() WITHIN GROUP (ORDER BY w.kind) AS common_dismissal_type -- Enrichment: Finds the most frequent dismissal method (e.g., 'lbw', 'caught')
    FROM Deliveries AS d
    JOIN TargetBowler tp ON d.bowler_identifier = tp.bowler_id -- Optimized Join: Matches against the static ID from the CTE
    JOIN Players AS p_bat ON d.batter_identifier = p_bat.identifier
    LEFT JOIN Wickets AS w ON d.delivery_id = w.delivery_id -- Join wickets to count dismissals by this bowler
    GROUP BY
      p_bat.first_last_name
    HAVING
      COUNT(*) >= 30 -- Apply the user's threshold to filter out small sample sizes
    ORDER BY
      strike_rate DESC
    LIMIT 10; -- default limit